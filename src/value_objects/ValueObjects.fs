module ValueObjects

(*
In DDD terminology, objects with a persitent identity
are called Entities and objects without a persitent
identity are called Value Objects.

In many cases, the data objects we area dealing with
have no identity -- they are interchangeable.
For example, one instance of a WidgeCode with value "W1234"
is the same as any other WidgetCode with value "w1234".
*)

type WidgetCode = WidgetCode of string

// true
printfn "%b" (WidgetCode "W1234" = WidgetCode "W1234")

(*
The concept of values without identity shows up frequently in a
domain model. For example, a PersonalName record type
might have two fields FirstName and LastName,
but is is also a Value Object, because two personal names
with the same fields are interchangeable.
*)
type PersonalName = { FirstName: string; LastName: string }

// true
printfn "%b" ({ FirstName = "John"; LastName = "Doe" } = { FirstName = "John"; LastName = "Doe" })

(*
An address type is also a Value Object. If two values have
the same street address an city and zip code, they are
the same address
*)
type Address =
  { Street: string
    City: string
    ZipCode: string }

// true
printfn
  "%b"
  ({ Street = "123 Main St"
     City = "New York"
     ZipCode = "90001" } = { Street = "123 Main St"
                             City = "New York"
                             ZipCode = "90001" })

(*
Equality

Types implement structural equality by default in F#
*)
type Option<'A> =
  | None
  | Some of 'A

// true
printfn "%b" (None = None)

// false
printfn "%b" (Some 1 = None)

// true
printfn "%b" (Some "hello world" = Some "hello world")

(*
Entities

We often model things that do have a unique identity,
even as their components change. For example, if a person
changes their address, they are still the same person.

In DDD terminology, we call such things Entities.

In a business context, entities are often a document of
some kind: Orders, Quote, Users.

Identity is dependent on context.

Identifiers

Entities need to have a stable identity despite any changes,
so we give them a unique identifier such as user id or order id.

For example, the Contact type below has an ID that stays the
same even if the PhoneNumber or EmailAddress fields change:
*)
type ContactID = ContactID of int

// We know if a contact is a specific concat by it's ID field.
type Contact =
  // The ID may be generated by the business, by a service or by the database.
  { ID: ContactID
    PhoneNumber: string
    EmailAddress: string }

(*
Implementing equality for entities

F# uses structural equality to compare two records.
But when we compare entities we want to use only one field,
the identifier.

NOTE: i actually don't.

The author suggests that we can override the auto generated comparison method.

NOTE: i think this is unnecessary, just access the id and compare it.
*)
[<CustomEquality; NoComparison>]
type Contact1 =
  { ID: ContactID
    PhoneNumber: string
    Email: string }
  override this.Equals(obj) =
    match obj with
    // :? is the type test operator,
    // we use it because apparently obj may not be a Contact1
    | :? Contact1 as c -> this.ID = c.ID
    | _ -> false

  override this.GetHashCode() = hash this.ID

let contactID = ContactID 1

let contact1: Contact1 =
  { ID = contactID
    PhoneNumber = "123"
    Email = "a@email.com" }

let contact2: Contact1 =
  { ID = contactID
    PhoneNumber = "123"
    Email = "a@email.com" }

// true because they have the same id
printfn "%b" (contact1 = contact2)

// We can disable equality testing for a type
// using the = operator would not compile
[<NoEquality; NoComparison>]
type User = { Email: string; Age: int }

(*
Updating records

We can use to with keyword to create a new record from an old
one with different values for its fields.
*)
let address1 =
  { Street = "123 Main St"
    City = "New York"
    ZipCode = "90001" }

// same values as address1 but City is "LA"
let address2 = { address1 with City = "LA" }

(*
Aggregates

An aggregate is a collection of domain objects that can be
treated as a single unit, with the top-level entity
acting as the root. Order an OrderLines for example.

All changes to objects inside an aggregate must be applied
via the tyop level, to the root, and the aggregate ccts
as a consistency boundary to ensure that all data inside
the aggregate is updated correctly at the same time.

An aggregate is the atomic unit of persistence,
database transactions and data transfer.
*)
